var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":true},"build":"omni_attitude_controller","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"/Users/wenshengfan/Documents/MATLAB/OAUAVSimluator/omni_attitude_controller_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: ert_main.c\n *\n * Code generated for Simulink model 'omni_attitude_controller'.\n *\n * Model version                  : 8.7\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\n * C/C++ source code generated on : Thu Dec 14 15:57:15 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#include <stddef.h>\n#include <stdio.h>            /* This example main program uses printf/fflush */\n#include \"omni_attitude_controller.h\"  /* Model header file */\n\n/*\n * Associating rt_OneStep with a real-time clock or interrupt service routine\n * is what makes the generated code \"real-time\".  The function rt_OneStep is\n * always associated with the base rate of the model.  Subrates are managed\n * by the base rate from inside the generated code.  Enabling/disabling\n * interrupts and floating point context switches are target specific.  This\n * example code indicates where these should take place relative to executing\n * the generated code step function.  Overrun behavior should be tailored to\n * your application needs.  This example simply sets an error status in the\n * real-time model and returns from rt_OneStep.\n */\nvoid rt_OneStep(void);\nvoid rt_OneStep(void)\n{\n  static boolean_T OverrunFlag = false;\n\n  /* Disable interrupts here */\n\n  /* Check for overrun */\n  if (OverrunFlag) {\n    return;\n  }\n\n  OverrunFlag = true;\n\n  /* Save FPU context here (if necessary) */\n  /* Re-enable timer or interrupt here */\n  /* Set model inputs here */\n\n  /* Step the model */\n  omni_attitude_controller_step();\n\n  /* Get model outputs here */\n\n  /* Indicate task complete */\n  OverrunFlag = false;\n\n  /* Disable interrupts here */\n  /* Restore FPU context here (if necessary) */\n  /* Enable interrupts here */\n}\n\n/*\n * The example main function illustrates what is required by your\n * application code to initialize, execute, and terminate the generated code.\n * Attaching rt_OneStep to a real-time clock is target specific. This example\n * illustrates how you do this relative to initializing the model.\n */\nint_T main(int_T argc, const char *argv[])\n{\n  /* Unused arguments */\n  (void)(argc);\n  (void)(argv);\n\n  /* Initialize model */\n  omni_attitude_controller_initialize();\n\n  /* Attach rt_OneStep to a timer or interrupt service routine with\n   * period 0.002 seconds (base rate of the model) here.\n   * The call syntax for rt_OneStep is\n   *\n   *  rt_OneStep();\n   */\n  printf(\"Warning: The simulation will run forever. \"\n         \"Generated ERT main won't simulate model step behavior. \"\n         \"To change this behavior select the 'MAT-file logging' option.\\n\");\n  fflush((NULL));\n  while (1) {\n    /*  Perform application tasks here */\n  }\n\n  /* The option 'Remove error status field in real-time model data structure'\n   * is selected, therefore the following code does not need to execute.\n   */\n\n  /* Terminate model */\n  omni_attitude_controller_terminate();\n  return 0;\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"omni_attitude_controller.c","type":"source","group":"model","path":"/Users/wenshengfan/Documents/MATLAB/OAUAVSimluator/omni_attitude_controller_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: omni_attitude_controller.c\n *\n * Code generated for Simulink model 'omni_attitude_controller'.\n *\n * Model version                  : 8.7\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\n * C/C++ source code generated on : Thu Dec 14 15:57:15 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#include \"omni_attitude_controller.h\"\n#include <math.h>\n#include \"rt_nonfinite.h\"\n#include \"rtwtypes.h\"\n#include <string.h>\n\n/* Block states (default storage) */\nDW_omni_attitude_controller_T omni_attitude_controller_DW;\n\n/* External inputs (root inport signals with default storage) */\nExtU_omni_attitude_controller_T omni_attitude_controller_U;\n\n/* External outputs (root outports fed by signals with default storage) */\nExtY_omni_attitude_controller_T omni_attitude_controller_Y;\n\n/* Model step function */\nvoid omni_attitude_controller_step(void)\n{\n  int32_T E_tmp_tmp;\n  int32_T i;\n  int32_T i_0;\n  real32_T E[9];\n  real32_T E_tmp[9];\n  real32_T rtb_VectorConcatenate[9];\n  real32_T rtb_VectorConcatenate_f[9];\n  real32_T rtb_VectorConcatenate_o[9];\n  real32_T rtb_VectorConcatenate_f_0[3];\n  real32_T rtb_eR[3];\n  real32_T rtb_eRiout[3];\n  real32_T tmp[3];\n  real32_T fty;\n  real32_T ftz;\n  real32_T rtb_Product1_a;\n  real32_T rtb_Product2_iz;\n  real32_T rtb_Product3_k;\n  real32_T rtb_Product_i;\n  real32_T rtb_VectorConcatenate_tmp;\n  real32_T rtb_VectorConcatenate_tmp_0;\n  real32_T rtb_VectorConcatenate_tmp_1;\n  real32_T rtb_VectorConcatenate_tmp_2;\n  real32_T rtb_VectorConcatenate_tmp_3;\n  real32_T rtb_motor_com_idx_3;\n\n  /* Sqrt: '<S16>/sqrt' incorporates:\n   *  Inport: '<Root>/qw_r'\n   *  Inport: '<Root>/qx_r'\n   *  Inport: '<Root>/qy_r'\n   *  Inport: '<Root>/qz_r'\n   *  Product: '<S17>/Product'\n   *  Product: '<S17>/Product1'\n   *  Product: '<S17>/Product2'\n   *  Product: '<S17>/Product3'\n   *  Sum: '<S17>/Sum'\n   */\n  rtb_Product2_iz = sqrtf(((omni_attitude_controller_U.qw_r *\n    omni_attitude_controller_U.qw_r + omni_attitude_controller_U.qx_r *\n    omni_attitude_controller_U.qx_r) + omni_attitude_controller_U.qy_r *\n    omni_attitude_controller_U.qy_r) + omni_attitude_controller_U.qz_r *\n    omni_attitude_controller_U.qz_r);\n\n  /* Product: '<S15>/Product' incorporates:\n   *  Inport: '<Root>/qw_r'\n   */\n  rtb_Product1_a = omni_attitude_controller_U.qw_r / rtb_Product2_iz;\n\n  /* Product: '<S15>/Product1' incorporates:\n   *  Inport: '<Root>/qx_r'\n   */\n  rtb_Product_i = omni_attitude_controller_U.qx_r / rtb_Product2_iz;\n\n  /* Product: '<S15>/Product2' incorporates:\n   *  Inport: '<Root>/qy_r'\n   */\n  rtb_Product3_k = omni_attitude_controller_U.qy_r / rtb_Product2_iz;\n\n  /* Product: '<S15>/Product3' incorporates:\n   *  Inport: '<Root>/qz_r'\n   */\n  rtb_Product2_iz = omni_attitude_controller_U.qz_r / rtb_Product2_iz;\n\n  /* Product: '<S5>/Product3' incorporates:\n   *  Product: '<S9>/Product3'\n   */\n  fty = rtb_Product1_a * rtb_Product1_a;\n\n  /* Product: '<S5>/Product2' incorporates:\n   *  Product: '<S9>/Product2'\n   */\n  ftz = rtb_Product_i * rtb_Product_i;\n\n  /* Product: '<S5>/Product1' incorporates:\n   *  Product: '<S13>/Product1'\n   *  Product: '<S9>/Product1'\n   */\n  rtb_motor_com_idx_3 = rtb_Product3_k * rtb_Product3_k;\n\n  /* Product: '<S5>/Product' incorporates:\n   *  Product: '<S13>/Product'\n   *  Product: '<S9>/Product'\n   */\n  rtb_VectorConcatenate_tmp_1 = rtb_Product2_iz * rtb_Product2_iz;\n\n  /* Sum: '<S5>/Sum' incorporates:\n   *  Product: '<S5>/Product'\n   *  Product: '<S5>/Product1'\n   *  Product: '<S5>/Product2'\n   *  Product: '<S5>/Product3'\n   */\n  rtb_VectorConcatenate[0] = ((fty + ftz) - rtb_motor_com_idx_3) -\n    rtb_VectorConcatenate_tmp_1;\n\n  /* Product: '<S8>/Product3' incorporates:\n   *  Product: '<S6>/Product3'\n   */\n  rtb_VectorConcatenate_tmp = rtb_Product2_iz * rtb_Product1_a;\n\n  /* Product: '<S8>/Product2' incorporates:\n   *  Product: '<S6>/Product2'\n   */\n  rtb_VectorConcatenate_tmp_0 = rtb_Product_i * rtb_Product3_k;\n\n  /* Gain: '<S8>/Gain' incorporates:\n   *  Product: '<S8>/Product2'\n   *  Product: '<S8>/Product3'\n   *  Sum: '<S8>/Sum'\n   */\n  rtb_VectorConcatenate[1] = (rtb_VectorConcatenate_tmp_0 -\n    rtb_VectorConcatenate_tmp) * omni_attitude_controller_P.Gain_Gain;\n\n  /* Product: '<S11>/Product2' incorporates:\n   *  Product: '<S7>/Product2'\n   */\n  rtb_VectorConcatenate_tmp_2 = rtb_Product_i * rtb_Product2_iz;\n\n  /* Product: '<S11>/Product1' incorporates:\n   *  Product: '<S7>/Product1'\n   */\n  rtb_VectorConcatenate_tmp_3 = rtb_Product1_a * rtb_Product3_k;\n\n  /* Gain: '<S11>/Gain' incorporates:\n   *  Product: '<S11>/Product1'\n   *  Product: '<S11>/Product2'\n   *  Sum: '<S11>/Sum'\n   */\n  rtb_VectorConcatenate[2] = (rtb_VectorConcatenate_tmp_3 +\n    rtb_VectorConcatenate_tmp_2) * omni_attitude_controller_P.Gain_Gain_l;\n\n  /* Gain: '<S6>/Gain' incorporates:\n   *  Sum: '<S6>/Sum'\n   */\n  rtb_VectorConcatenate[3] = (rtb_VectorConcatenate_tmp +\n    rtb_VectorConcatenate_tmp_0) * omni_attitude_controller_P.Gain_Gain_f;\n\n  /* Sum: '<S9>/Sum' incorporates:\n   *  Sum: '<S13>/Sum'\n   */\n  fty -= ftz;\n  rtb_VectorConcatenate[4] = (fty + rtb_motor_com_idx_3) -\n    rtb_VectorConcatenate_tmp_1;\n\n  /* Product: '<S12>/Product1' incorporates:\n   *  Product: '<S10>/Product1'\n   */\n  ftz = rtb_Product1_a * rtb_Product_i;\n\n  /* Product: '<S12>/Product2' incorporates:\n   *  Product: '<S10>/Product2'\n   */\n  rtb_VectorConcatenate_tmp = rtb_Product3_k * rtb_Product2_iz;\n\n  /* Gain: '<S12>/Gain' incorporates:\n   *  Product: '<S12>/Product1'\n   *  Product: '<S12>/Product2'\n   *  Sum: '<S12>/Sum'\n   */\n  rtb_VectorConcatenate[5] = (rtb_VectorConcatenate_tmp - ftz) *\n    omni_attitude_controller_P.Gain_Gain_d;\n\n  /* Gain: '<S7>/Gain' incorporates:\n   *  Sum: '<S7>/Sum'\n   */\n  rtb_VectorConcatenate[6] = (rtb_VectorConcatenate_tmp_2 -\n    rtb_VectorConcatenate_tmp_3) * omni_attitude_controller_P.Gain_Gain_b;\n\n  /* Gain: '<S10>/Gain' incorporates:\n   *  Sum: '<S10>/Sum'\n   */\n  rtb_VectorConcatenate[7] = (ftz + rtb_VectorConcatenate_tmp) *\n    omni_attitude_controller_P.Gain_Gain_c;\n\n  /* Sum: '<S13>/Sum' */\n  rtb_VectorConcatenate[8] = (fty - rtb_motor_com_idx_3) +\n    rtb_VectorConcatenate_tmp_1;\n\n  /* Sqrt: '<S29>/sqrt' incorporates:\n   *  Inport: '<Root>/qw_IMU'\n   *  Inport: '<Root>/qx_IMU'\n   *  Inport: '<Root>/qy_IMU'\n   *  Inport: '<Root>/qz_IMU'\n   *  Product: '<S30>/Product'\n   *  Product: '<S30>/Product1'\n   *  Product: '<S30>/Product2'\n   *  Product: '<S30>/Product3'\n   *  Sum: '<S30>/Sum'\n   */\n  rtb_Product3_k = sqrtf(((omni_attitude_controller_U.qw_IMU *\n    omni_attitude_controller_U.qw_IMU + omni_attitude_controller_U.qx_IMU *\n    omni_attitude_controller_U.qx_IMU) + omni_attitude_controller_U.qy_IMU *\n    omni_attitude_controller_U.qy_IMU) + omni_attitude_controller_U.qz_IMU *\n    omni_attitude_controller_U.qz_IMU);\n\n  /* Product: '<S28>/Product' incorporates:\n   *  Inport: '<Root>/qw_IMU'\n   */\n  rtb_Product_i = omni_attitude_controller_U.qw_IMU / rtb_Product3_k;\n\n  /* Product: '<S28>/Product1' incorporates:\n   *  Inport: '<Root>/qx_IMU'\n   */\n  rtb_Product1_a = omni_attitude_controller_U.qx_IMU / rtb_Product3_k;\n\n  /* Product: '<S28>/Product2' incorporates:\n   *  Inport: '<Root>/qy_IMU'\n   */\n  rtb_Product2_iz = omni_attitude_controller_U.qy_IMU / rtb_Product3_k;\n\n  /* Product: '<S28>/Product3' incorporates:\n   *  Inport: '<Root>/qz_IMU'\n   */\n  rtb_Product3_k = omni_attitude_controller_U.qz_IMU / rtb_Product3_k;\n\n  /* Product: '<S18>/Product3' incorporates:\n   *  Product: '<S22>/Product3'\n   */\n  fty = rtb_Product_i * rtb_Product_i;\n\n  /* Product: '<S18>/Product2' incorporates:\n   *  Product: '<S22>/Product2'\n   */\n  ftz = rtb_Product1_a * rtb_Product1_a;\n\n  /* Product: '<S18>/Product1' incorporates:\n   *  Product: '<S22>/Product1'\n   *  Product: '<S26>/Product1'\n   */\n  rtb_motor_com_idx_3 = rtb_Product2_iz * rtb_Product2_iz;\n\n  /* Product: '<S18>/Product' incorporates:\n   *  Product: '<S22>/Product'\n   *  Product: '<S26>/Product'\n   */\n  rtb_VectorConcatenate_tmp_1 = rtb_Product3_k * rtb_Product3_k;\n\n  /* Sum: '<S18>/Sum' incorporates:\n   *  Product: '<S18>/Product'\n   *  Product: '<S18>/Product1'\n   *  Product: '<S18>/Product2'\n   *  Product: '<S18>/Product3'\n   */\n  rtb_VectorConcatenate_o[0] = ((fty + ftz) - rtb_motor_com_idx_3) -\n    rtb_VectorConcatenate_tmp_1;\n\n  /* Product: '<S21>/Product3' incorporates:\n   *  Product: '<S19>/Product3'\n   */\n  rtb_VectorConcatenate_tmp = rtb_Product3_k * rtb_Product_i;\n\n  /* Product: '<S21>/Product2' incorporates:\n   *  Product: '<S19>/Product2'\n   */\n  rtb_VectorConcatenate_tmp_0 = rtb_Product1_a * rtb_Product2_iz;\n\n  /* Gain: '<S21>/Gain' incorporates:\n   *  Product: '<S21>/Product2'\n   *  Product: '<S21>/Product3'\n   *  Sum: '<S21>/Sum'\n   */\n  rtb_VectorConcatenate_o[1] = (rtb_VectorConcatenate_tmp_0 -\n    rtb_VectorConcatenate_tmp) * omni_attitude_controller_P.Gain_Gain_p;\n\n  /* Product: '<S24>/Product2' incorporates:\n   *  Product: '<S20>/Product2'\n   */\n  rtb_VectorConcatenate_tmp_2 = rtb_Product1_a * rtb_Product3_k;\n\n  /* Product: '<S24>/Product1' incorporates:\n   *  Product: '<S20>/Product1'\n   */\n  rtb_VectorConcatenate_tmp_3 = rtb_Product_i * rtb_Product2_iz;\n\n  /* Gain: '<S24>/Gain' incorporates:\n   *  Product: '<S24>/Product1'\n   *  Product: '<S24>/Product2'\n   *  Sum: '<S24>/Sum'\n   */\n  rtb_VectorConcatenate_o[2] = (rtb_VectorConcatenate_tmp_3 +\n    rtb_VectorConcatenate_tmp_2) * omni_attitude_controller_P.Gain_Gain_i;\n\n  /* Gain: '<S19>/Gain' incorporates:\n   *  Sum: '<S19>/Sum'\n   */\n  rtb_VectorConcatenate_o[3] = (rtb_VectorConcatenate_tmp +\n    rtb_VectorConcatenate_tmp_0) * omni_attitude_controller_P.Gain_Gain_fl;\n\n  /* Sum: '<S22>/Sum' incorporates:\n   *  Sum: '<S26>/Sum'\n   */\n  fty -= ftz;\n  rtb_VectorConcatenate_o[4] = (fty + rtb_motor_com_idx_3) -\n    rtb_VectorConcatenate_tmp_1;\n\n  /* Product: '<S25>/Product1' incorporates:\n   *  Product: '<S23>/Product1'\n   */\n  ftz = rtb_Product_i * rtb_Product1_a;\n\n  /* Product: '<S25>/Product2' incorporates:\n   *  Product: '<S23>/Product2'\n   */\n  rtb_VectorConcatenate_tmp = rtb_Product2_iz * rtb_Product3_k;\n\n  /* Gain: '<S25>/Gain' incorporates:\n   *  Product: '<S25>/Product1'\n   *  Product: '<S25>/Product2'\n   *  Sum: '<S25>/Sum'\n   */\n  rtb_VectorConcatenate_o[5] = (rtb_VectorConcatenate_tmp - ftz) *\n    omni_attitude_controller_P.Gain_Gain_a;\n\n  /* Gain: '<S20>/Gain' incorporates:\n   *  Sum: '<S20>/Sum'\n   */\n  rtb_VectorConcatenate_o[6] = (rtb_VectorConcatenate_tmp_2 -\n    rtb_VectorConcatenate_tmp_3) * omni_attitude_controller_P.Gain_Gain_h;\n\n  /* Gain: '<S23>/Gain' incorporates:\n   *  Sum: '<S23>/Sum'\n   */\n  rtb_VectorConcatenate_o[7] = (ftz + rtb_VectorConcatenate_tmp) *\n    omni_attitude_controller_P.Gain_Gain_ao;\n\n  /* Sum: '<S26>/Sum' */\n  rtb_VectorConcatenate_o[8] = (fty - rtb_motor_com_idx_3) +\n    rtb_VectorConcatenate_tmp_1;\n\n  /* MATLAB Function: '<Root>/LLATC' incorporates:\n   *  Concatenate: '<S14>/Vector Concatenate'\n   *  Concatenate: '<S27>/Vector Concatenate'\n   *  Inport: '<Root>/gyro_x'\n   *  Inport: '<Root>/gyro_y'\n   *  Inport: '<Root>/gyro_z'\n   *  Memory: '<Root>/Memory5'\n   */\n  for (i = 0; i < 3; i++) {\n    rtb_Product3_k = rtb_VectorConcatenate_o[3 * i + 1];\n    rtb_Product2_iz = rtb_VectorConcatenate_o[3 * i];\n    rtb_Product1_a = rtb_VectorConcatenate_o[3 * i + 2];\n    for (i_0 = 0; i_0 < 3; i_0++) {\n      E_tmp_tmp = 3 * i_0 + i;\n      E_tmp[i_0 + 3 * i] = rtb_VectorConcatenate[E_tmp_tmp];\n      rtb_VectorConcatenate_f[E_tmp_tmp] = (rtb_VectorConcatenate[3 * i_0 + 1] *\n        rtb_Product3_k + rtb_VectorConcatenate[3 * i_0] * rtb_Product2_iz) +\n        rtb_VectorConcatenate[3 * i_0 + 2] * rtb_Product1_a;\n    }\n  }\n\n  for (i = 0; i < 3; i++) {\n    rtb_Product3_k = rtb_VectorConcatenate_o[3 * i + 1];\n    rtb_Product2_iz = rtb_VectorConcatenate_o[3 * i];\n    rtb_Product1_a = rtb_VectorConcatenate_o[3 * i + 2];\n    for (i_0 = 0; i_0 < 3; i_0++) {\n      rtb_VectorConcatenate[i_0 + 3 * i] = (E_tmp[i_0 + 3] * rtb_Product3_k +\n        rtb_Product2_iz * E_tmp[i_0]) + E_tmp[i_0 + 6] * rtb_Product1_a;\n    }\n  }\n\n  for (i = 0; i < 9; i++) {\n    E[i] = (rtb_VectorConcatenate_f[i] - rtb_VectorConcatenate[i]) * 0.5F;\n  }\n\n  rtb_eR[0] = E[5];\n  rtb_eR[1] = E[6];\n  rtb_eR[2] = E[1];\n  for (i = 0; i < 3; i++) {\n    rtb_eRiout[i] = rtb_eR[i] * 0.01F +\n      omni_attitude_controller_DW.Memory5_PreviousInput[i];\n    rtb_VectorConcatenate_f_0[i] = (rtb_VectorConcatenate_o[i + 3] *\n      omni_attitude_controller_U.gyro_y + rtb_VectorConcatenate_o[i] *\n      omni_attitude_controller_U.gyro_x) + rtb_VectorConcatenate_o[i + 6] *\n      omni_attitude_controller_U.gyro_z;\n  }\n\n  /* SignalConversion generated from: '<S1>/ SFunction ' incorporates:\n   *  Inport: '<Root>/wx_r'\n   *  Inport: '<Root>/wy_r'\n   *  Inport: '<Root>/wz_r'\n   *  MATLAB Function: '<Root>/LLATC'\n   */\n  rtb_eR[0] = omni_attitude_controller_U.wx_r;\n  rtb_eR[1] = omni_attitude_controller_U.wy_r;\n  rtb_eR[2] = omni_attitude_controller_U.wz_r;\n\n  /* MATLAB Function: '<Root>/LLATC' */\n  rtb_Product3_k = rtb_VectorConcatenate_f_0[1];\n  rtb_Product2_iz = rtb_VectorConcatenate_f_0[0];\n  rtb_Product1_a = rtb_VectorConcatenate_f_0[2];\n  for (i = 0; i < 3; i++) {\n    rtb_VectorConcatenate_f_0[i] = rtb_eR[i] - ((E_tmp[i + 3] * rtb_Product3_k +\n      E_tmp[i] * rtb_Product2_iz) + E_tmp[i + 6] * rtb_Product1_a);\n  }\n\n  rtb_Product3_k = rtb_VectorConcatenate_f_0[1];\n  rtb_Product2_iz = rtb_VectorConcatenate_f_0[0];\n  rtb_Product1_a = rtb_VectorConcatenate_f_0[2];\n  rtb_Product_i = E[6];\n  fty = E[5];\n  ftz = E[1];\n  for (i = 0; i < 3; i++) {\n    rtb_VectorConcatenate_f_0[i] = ((real32_T)omni_attitude_controller_P.Kw[i +\n      3] * rtb_Product3_k + (real32_T)omni_attitude_controller_P.Kw[i] *\n      rtb_Product2_iz) + (real32_T)omni_attitude_controller_P.Kw[i + 6] *\n      rtb_Product1_a;\n    rtb_eR[i] = ((real32_T)omni_attitude_controller_P.KR[i + 3] * rtb_Product_i\n                 + (real32_T)omni_attitude_controller_P.KR[i] * fty) + (real32_T)\n      omni_attitude_controller_P.KR[i + 6] * ftz;\n  }\n\n  for (i = 0; i < 9; i++) {\n    rtb_VectorConcatenate_o[i] = (real32_T)-omni_attitude_controller_P.Ji[i];\n  }\n\n  rtb_Product3_k = rtb_eRiout[1];\n  rtb_Product2_iz = rtb_eRiout[0];\n  rtb_Product1_a = rtb_eRiout[2];\n  for (i = 0; i < 3; i++) {\n    tmp[i] = (((real32_T)omni_attitude_controller_P.Ki[i + 3] * rtb_Product3_k +\n               (real32_T)omni_attitude_controller_P.Ki[i] * rtb_Product2_iz) +\n              (real32_T)omni_attitude_controller_P.Ki[i + 6] * rtb_Product1_a) +\n      (rtb_eR[i] + rtb_VectorConcatenate_f_0[i]);\n  }\n\n  rtb_Product3_k = tmp[1];\n  rtb_Product2_iz = tmp[0];\n  rtb_Product1_a = tmp[2];\n  for (i = 0; i < 3; i++) {\n    rtb_eR[i] = (rtb_VectorConcatenate_o[i + 3] * rtb_Product3_k +\n                 rtb_VectorConcatenate_o[i] * rtb_Product2_iz) +\n      rtb_VectorConcatenate_o[i + 6] * rtb_Product1_a;\n  }\n\n  /* Saturate: '<Root>/Saturation' incorporates:\n   *  Inport: '<Root>/thrust'\n   */\n  if (omni_attitude_controller_U.thrust >\n      omni_attitude_controller_P.Saturation_UpperSat) {\n    rtb_Product3_k = omni_attitude_controller_P.Saturation_UpperSat;\n  } else if (omni_attitude_controller_U.thrust <\n             omni_attitude_controller_P.Saturation_LowerSat) {\n    rtb_Product3_k = omni_attitude_controller_P.Saturation_LowerSat;\n  } else {\n    rtb_Product3_k = omni_attitude_controller_U.thrust;\n  }\n\n  /* MATLAB Function: '<Root>/MATLAB Function1' incorporates:\n   *  Constant: '<Root>/Constant'\n   *  Saturate: '<Root>/Saturation'\n   */\n  rtb_Product3_k /= 4.0F;\n  rtb_Product1_a = rtb_eR[0] / 4.0F / 0.03165F;\n  fty = rtb_eR[1] / 4.0F / 0.03165F;\n  ftz = rtb_eR[2] / 4.0F / 0.03165F * (real32_T)\n    omni_attitude_controller_P.Constant_Value;\n  rtb_motor_com_idx_3 = rtb_Product3_k + rtb_Product1_a;\n  rtb_Product2_iz = (rtb_motor_com_idx_3 - fty) - ftz;\n  rtb_Product3_k -= rtb_Product1_a;\n  rtb_Product1_a = (rtb_Product3_k - fty) + ftz;\n  rtb_Product_i = (rtb_Product3_k + fty) - ftz;\n  rtb_Product3_k = (rtb_motor_com_idx_3 + fty) + ftz;\n  if (rtb_Product2_iz < 0.0F) {\n    rtb_Product2_iz = 0.0F;\n  }\n\n  if (rtb_Product1_a < 0.0F) {\n    rtb_Product1_a = 0.0F;\n  }\n\n  if (rtb_Product_i < 0.0F) {\n    rtb_Product_i = 0.0F;\n  }\n\n  if (rtb_Product3_k < 0.0F) {\n    rtb_Product3_k = 0.0F;\n  }\n\n  fty = rtb_Product2_iz / 0.1472F * 65535.0F;\n  ftz = rtb_Product1_a / 0.1472F * 65535.0F;\n  rtb_Product_i = rtb_Product_i / 0.1472F * 65535.0F;\n  rtb_motor_com_idx_3 = rtb_Product3_k / 0.1472F * 65535.0F;\n\n  /* End of MATLAB Function: '<Root>/MATLAB Function1' */\n\n  /* Saturate: '<Root>/Saturation1' */\n  if (fty > omni_attitude_controller_P.Saturation1_UpperSat) {\n    rtb_Product3_k = omni_attitude_controller_P.Saturation1_UpperSat;\n  } else if (fty < omni_attitude_controller_P.Saturation1_LowerSat) {\n    rtb_Product3_k = omni_attitude_controller_P.Saturation1_LowerSat;\n  } else {\n    rtb_Product3_k = fty;\n  }\n\n  /* DataTypeConversion: '<Root>/Data Type Conversion2' incorporates:\n   *  Saturate: '<Root>/Saturation1'\n   */\n  rtb_Product3_k = floorf(rtb_Product3_k);\n  if (rtIsNaNF(rtb_Product3_k) || rtIsInfF(rtb_Product3_k)) {\n    rtb_Product3_k = 0.0F;\n  } else {\n    rtb_Product3_k = fmodf(rtb_Product3_k, 65536.0F);\n  }\n\n  /* Saturate: '<Root>/Saturation1' */\n  if (ftz > omni_attitude_controller_P.Saturation1_UpperSat) {\n    rtb_Product2_iz = omni_attitude_controller_P.Saturation1_UpperSat;\n  } else if (ftz < omni_attitude_controller_P.Saturation1_LowerSat) {\n    rtb_Product2_iz = omni_attitude_controller_P.Saturation1_LowerSat;\n  } else {\n    rtb_Product2_iz = ftz;\n  }\n\n  /* DataTypeConversion: '<Root>/Data Type Conversion2' incorporates:\n   *  Saturate: '<Root>/Saturation1'\n   */\n  rtb_Product2_iz = floorf(rtb_Product2_iz);\n  if (rtIsNaNF(rtb_Product2_iz) || rtIsInfF(rtb_Product2_iz)) {\n    rtb_Product2_iz = 0.0F;\n  } else {\n    rtb_Product2_iz = fmodf(rtb_Product2_iz, 65536.0F);\n  }\n\n  /* Saturate: '<Root>/Saturation1' */\n  if (rtb_Product_i > omni_attitude_controller_P.Saturation1_UpperSat) {\n    rtb_Product1_a = omni_attitude_controller_P.Saturation1_UpperSat;\n  } else if (rtb_Product_i < omni_attitude_controller_P.Saturation1_LowerSat) {\n    rtb_Product1_a = omni_attitude_controller_P.Saturation1_LowerSat;\n  } else {\n    rtb_Product1_a = rtb_Product_i;\n  }\n\n  /* DataTypeConversion: '<Root>/Data Type Conversion2' incorporates:\n   *  Saturate: '<Root>/Saturation1'\n   */\n  rtb_Product1_a = floorf(rtb_Product1_a);\n  if (rtIsNaNF(rtb_Product1_a) || rtIsInfF(rtb_Product1_a)) {\n    rtb_Product1_a = 0.0F;\n  } else {\n    rtb_Product1_a = fmodf(rtb_Product1_a, 65536.0F);\n  }\n\n  /* Saturate: '<Root>/Saturation1' */\n  if (rtb_motor_com_idx_3 > omni_attitude_controller_P.Saturation1_UpperSat) {\n    rtb_VectorConcatenate_tmp_1 =\n      omni_attitude_controller_P.Saturation1_UpperSat;\n  } else if (rtb_motor_com_idx_3 <\n             omni_attitude_controller_P.Saturation1_LowerSat) {\n    rtb_VectorConcatenate_tmp_1 =\n      omni_attitude_controller_P.Saturation1_LowerSat;\n  } else {\n    rtb_VectorConcatenate_tmp_1 = rtb_motor_com_idx_3;\n  }\n\n  /* DataTypeConversion: '<Root>/Data Type Conversion2' incorporates:\n   *  Saturate: '<Root>/Saturation1'\n   */\n  rtb_VectorConcatenate_tmp_1 = floorf(rtb_VectorConcatenate_tmp_1);\n  if (rtIsNaNF(rtb_VectorConcatenate_tmp_1) || rtIsInfF\n      (rtb_VectorConcatenate_tmp_1)) {\n    rtb_VectorConcatenate_tmp_1 = 0.0F;\n  } else {\n    rtb_VectorConcatenate_tmp_1 = fmodf(rtb_VectorConcatenate_tmp_1, 65536.0F);\n  }\n\n  /* Outport: '<Root>/m1' incorporates:\n   *  DataTypeConversion: '<Root>/Data Type Conversion2'\n   */\n  omni_attitude_controller_Y.m1 = (uint16_T)(rtb_Product3_k < 0.0F ? (int32_T)\n    (uint16_T)-(int16_T)(uint16_T)-rtb_Product3_k : (int32_T)(uint16_T)\n    rtb_Product3_k);\n\n  /* Outport: '<Root>/m2' incorporates:\n   *  DataTypeConversion: '<Root>/Data Type Conversion2'\n   */\n  omni_attitude_controller_Y.m2 = (uint16_T)(rtb_Product2_iz < 0.0F ? (int32_T)\n    (uint16_T)-(int16_T)(uint16_T)-rtb_Product2_iz : (int32_T)(uint16_T)\n    rtb_Product2_iz);\n\n  /* Outport: '<Root>/m3' incorporates:\n   *  DataTypeConversion: '<Root>/Data Type Conversion2'\n   */\n  omni_attitude_controller_Y.m3 = (uint16_T)(rtb_Product1_a < 0.0F ? (int32_T)\n    (uint16_T)-(int16_T)(uint16_T)-rtb_Product1_a : (int32_T)(uint16_T)\n    rtb_Product1_a);\n\n  /* Outport: '<Root>/m4' incorporates:\n   *  DataTypeConversion: '<Root>/Data Type Conversion2'\n   */\n  omni_attitude_controller_Y.m4 = (uint16_T)(rtb_VectorConcatenate_tmp_1 < 0.0F ?\n    (int32_T)(uint16_T)-(int16_T)(uint16_T)-rtb_VectorConcatenate_tmp_1 :\n    (int32_T)(uint16_T)rtb_VectorConcatenate_tmp_1);\n\n  /* Outport: '<Root>/t_m1' */\n  omni_attitude_controller_Y.t_m1 = fty;\n\n  /* Outport: '<Root>/t_m2' */\n  omni_attitude_controller_Y.t_m2 = ftz;\n\n  /* Outport: '<Root>/t_m3' */\n  omni_attitude_controller_Y.t_m3 = rtb_Product_i;\n\n  /* Outport: '<Root>/t_m4' */\n  omni_attitude_controller_Y.t_m4 = rtb_motor_com_idx_3;\n\n  /* Update for Memory: '<Root>/Memory5' */\n  omni_attitude_controller_DW.Memory5_PreviousInput[0] = rtb_eRiout[0];\n  omni_attitude_controller_DW.Memory5_PreviousInput[1] = rtb_eRiout[1];\n  omni_attitude_controller_DW.Memory5_PreviousInput[2] = rtb_eRiout[2];\n}\n\n/* Model initialize function */\nvoid omni_attitude_controller_initialize(void)\n{\n  /* Registration code */\n\n  /* initialize non-finites */\n  rt_InitInfAndNaN(sizeof(real_T));\n\n  /* states (dwork) */\n  (void) memset((void *)&omni_attitude_controller_DW, 0,\n                sizeof(DW_omni_attitude_controller_T));\n\n  /* external inputs */\n  (void)memset(&omni_attitude_controller_U, 0, sizeof\n               (ExtU_omni_attitude_controller_T));\n\n  /* external outputs */\n  (void)memset(&omni_attitude_controller_Y, 0, sizeof\n               (ExtY_omni_attitude_controller_T));\n\n  /* InitializeConditions for Memory: '<Root>/Memory5' */\n  omni_attitude_controller_DW.Memory5_PreviousInput[0] =\n    omni_attitude_controller_P.Memory5_InitialCondition[0];\n  omni_attitude_controller_DW.Memory5_PreviousInput[1] =\n    omni_attitude_controller_P.Memory5_InitialCondition[1];\n  omni_attitude_controller_DW.Memory5_PreviousInput[2] =\n    omni_attitude_controller_P.Memory5_InitialCondition[2];\n}\n\n/* Model terminate function */\nvoid omni_attitude_controller_terminate(void)\n{\n  /* (no terminate code required) */\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"omni_attitude_controller.h","type":"header","group":"model","path":"/Users/wenshengfan/Documents/MATLAB/OAUAVSimluator/omni_attitude_controller_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: omni_attitude_controller.h\n *\n * Code generated for Simulink model 'omni_attitude_controller'.\n *\n * Model version                  : 8.7\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\n * C/C++ source code generated on : Thu Dec 14 15:57:15 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_omni_attitude_controller_h_\n#define RTW_HEADER_omni_attitude_controller_h_\n#ifndef omni_attitude_controller_COMMON_INCLUDES_\n#define omni_attitude_controller_COMMON_INCLUDES_\n#include \"rtwtypes.h\"\n#endif                           /* omni_attitude_controller_COMMON_INCLUDES_ */\n\n#include \"omni_attitude_controller_types.h\"\n#include <string.h>\n#include \"rt_nonfinite.h\"\n\n/* Block states (default storage) for system '<Root>' */\ntypedef struct {\n  real32_T Memory5_PreviousInput[3];   /* '<Root>/Memory5' */\n} DW_omni_attitude_controller_T;\n\n/* External inputs (root inport signals with default storage) */\ntypedef struct {\n  real32_T thrust;                     /* '<Root>/thrust' */\n  real32_T qw_r;                       /* '<Root>/qw_r' */\n  real32_T qx_r;                       /* '<Root>/qx_r' */\n  real32_T qy_r;                       /* '<Root>/qy_r' */\n  real32_T qz_r;                       /* '<Root>/qz_r' */\n  real32_T qw_IMU;                     /* '<Root>/qw_IMU' */\n  real32_T qx_IMU;                     /* '<Root>/qx_IMU' */\n  real32_T qy_IMU;                     /* '<Root>/qy_IMU' */\n  real32_T qz_IMU;                     /* '<Root>/qz_IMU' */\n  real32_T wx_r;                       /* '<Root>/wx_r' */\n  real32_T wy_r;                       /* '<Root>/wy_r' */\n  real32_T wz_r;                       /* '<Root>/wz_r' */\n  real32_T gyro_x;                     /* '<Root>/gyro_x' */\n  real32_T gyro_y;                     /* '<Root>/gyro_y' */\n  real32_T gyro_z;                     /* '<Root>/gyro_z' */\n} ExtU_omni_attitude_controller_T;\n\n/* External outputs (root outports fed by signals with default storage) */\ntypedef struct {\n  uint16_T m1;                         /* '<Root>/m1' */\n  uint16_T m2;                         /* '<Root>/m2' */\n  uint16_T m3;                         /* '<Root>/m3' */\n  uint16_T m4;                         /* '<Root>/m4' */\n  real32_T t_m1;                       /* '<Root>/t_m1' */\n  real32_T t_m2;                       /* '<Root>/t_m2' */\n  real32_T t_m3;                       /* '<Root>/t_m3' */\n  real32_T t_m4;                       /* '<Root>/t_m4' */\n} ExtY_omni_attitude_controller_T;\n\n/* Parameters (default storage) */\nstruct P_omni_attitude_controller_T_ {\n  real_T Ji[9];                        /* Variable: Ji\n                                        * Referenced by: '<Root>/LLATC'\n                                        */\n  real_T KR[9];                        /* Variable: KR\n                                        * Referenced by: '<Root>/LLATC'\n                                        */\n  real_T Ki[9];                        /* Variable: Ki\n                                        * Referenced by: '<Root>/LLATC'\n                                        */\n  real_T Kw[9];                        /* Variable: Kw\n                                        * Referenced by: '<Root>/LLATC'\n                                        */\n  real_T Constant_Value;               /* Expression: (31.65e-3)/(5.964552e-3)\n                                        * Referenced by: '<Root>/Constant'\n                                        */\n  real32_T Saturation_UpperSat;       /* Computed Parameter: Saturation_UpperSat\n                                       * Referenced by: '<Root>/Saturation'\n                                       */\n  real32_T Saturation_LowerSat;       /* Computed Parameter: Saturation_LowerSat\n                                       * Referenced by: '<Root>/Saturation'\n                                       */\n  real32_T Gain_Gain;                  /* Computed Parameter: Gain_Gain\n                                        * Referenced by: '<S8>/Gain'\n                                        */\n  real32_T Gain_Gain_l;                /* Computed Parameter: Gain_Gain_l\n                                        * Referenced by: '<S11>/Gain'\n                                        */\n  real32_T Gain_Gain_f;                /* Computed Parameter: Gain_Gain_f\n                                        * Referenced by: '<S6>/Gain'\n                                        */\n  real32_T Gain_Gain_d;                /* Computed Parameter: Gain_Gain_d\n                                        * Referenced by: '<S12>/Gain'\n                                        */\n  real32_T Gain_Gain_b;                /* Computed Parameter: Gain_Gain_b\n                                        * Referenced by: '<S7>/Gain'\n                                        */\n  real32_T Gain_Gain_c;                /* Computed Parameter: Gain_Gain_c\n                                        * Referenced by: '<S10>/Gain'\n                                        */\n  real32_T Gain_Gain_p;                /* Computed Parameter: Gain_Gain_p\n                                        * Referenced by: '<S21>/Gain'\n                                        */\n  real32_T Gain_Gain_i;                /* Computed Parameter: Gain_Gain_i\n                                        * Referenced by: '<S24>/Gain'\n                                        */\n  real32_T Gain_Gain_fl;               /* Computed Parameter: Gain_Gain_fl\n                                        * Referenced by: '<S19>/Gain'\n                                        */\n  real32_T Gain_Gain_a;                /* Computed Parameter: Gain_Gain_a\n                                        * Referenced by: '<S25>/Gain'\n                                        */\n  real32_T Gain_Gain_h;                /* Computed Parameter: Gain_Gain_h\n                                        * Referenced by: '<S20>/Gain'\n                                        */\n  real32_T Gain_Gain_ao;               /* Computed Parameter: Gain_Gain_ao\n                                        * Referenced by: '<S23>/Gain'\n                                        */\n  real32_T Memory5_InitialCondition[3];\n                                 /* Computed Parameter: Memory5_InitialCondition\n                                  * Referenced by: '<Root>/Memory5'\n                                  */\n  real32_T Saturation1_UpperSat;     /* Computed Parameter: Saturation1_UpperSat\n                                      * Referenced by: '<Root>/Saturation1'\n                                      */\n  real32_T Saturation1_LowerSat;     /* Computed Parameter: Saturation1_LowerSat\n                                      * Referenced by: '<Root>/Saturation1'\n                                      */\n};\n\n/* Block parameters (default storage) */\nextern P_omni_attitude_controller_T omni_attitude_controller_P;\n\n/* Block states (default storage) */\nextern DW_omni_attitude_controller_T omni_attitude_controller_DW;\n\n/* External inputs (root inport signals with default storage) */\nextern ExtU_omni_attitude_controller_T omni_attitude_controller_U;\n\n/* External outputs (root outports fed by signals with default storage) */\nextern ExtY_omni_attitude_controller_T omni_attitude_controller_Y;\n\n/* Model entry point functions */\nextern void omni_attitude_controller_initialize(void);\nextern void omni_attitude_controller_step(void);\nextern void omni_attitude_controller_terminate(void);\n\n/*-\n * These blocks were eliminated from the model due to optimizations:\n *\n * Block '<S14>/Reshape (9) to [3x3] column-major' : Reshape block reduction\n * Block '<S27>/Reshape (9) to [3x3] column-major' : Reshape block reduction\n */\n\n/*-\n * The generated code includes comments that allow you to trace directly\n * back to the appropriate location in the model.  The basic format\n * is <system>/block_name, where system is the system number (uniquely\n * assigned by Simulink) and block_name is the name of the block.\n *\n * Use the MATLAB hilite_system command to trace the generated code back\n * to the model.  For example,\n *\n * hilite_system('<S3>')    - opens system 3\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\n *\n * Here is the system hierarchy for this model\n *\n * '<Root>' : 'omni_attitude_controller'\n * '<S1>'   : 'omni_attitude_controller/LLATC'\n * '<S2>'   : 'omni_attitude_controller/MATLAB Function1'\n * '<S3>'   : 'omni_attitude_controller/Quaternions to  Direction Cosine Matrix'\n * '<S4>'   : 'omni_attitude_controller/Quaternions to  Direction Cosine Matrix1'\n * '<S5>'   : 'omni_attitude_controller/Quaternions to  Direction Cosine Matrix/A11'\n * '<S6>'   : 'omni_attitude_controller/Quaternions to  Direction Cosine Matrix/A12'\n * '<S7>'   : 'omni_attitude_controller/Quaternions to  Direction Cosine Matrix/A13'\n * '<S8>'   : 'omni_attitude_controller/Quaternions to  Direction Cosine Matrix/A21'\n * '<S9>'   : 'omni_attitude_controller/Quaternions to  Direction Cosine Matrix/A22'\n * '<S10>'  : 'omni_attitude_controller/Quaternions to  Direction Cosine Matrix/A23'\n * '<S11>'  : 'omni_attitude_controller/Quaternions to  Direction Cosine Matrix/A31'\n * '<S12>'  : 'omni_attitude_controller/Quaternions to  Direction Cosine Matrix/A32'\n * '<S13>'  : 'omni_attitude_controller/Quaternions to  Direction Cosine Matrix/A33'\n * '<S14>'  : 'omni_attitude_controller/Quaternions to  Direction Cosine Matrix/Create 3x3 Matrix'\n * '<S15>'  : 'omni_attitude_controller/Quaternions to  Direction Cosine Matrix/Quaternion Normalize'\n * '<S16>'  : 'omni_attitude_controller/Quaternions to  Direction Cosine Matrix/Quaternion Normalize/Quaternion Modulus'\n * '<S17>'  : 'omni_attitude_controller/Quaternions to  Direction Cosine Matrix/Quaternion Normalize/Quaternion Modulus/Quaternion Norm'\n * '<S18>'  : 'omni_attitude_controller/Quaternions to  Direction Cosine Matrix1/A11'\n * '<S19>'  : 'omni_attitude_controller/Quaternions to  Direction Cosine Matrix1/A12'\n * '<S20>'  : 'omni_attitude_controller/Quaternions to  Direction Cosine Matrix1/A13'\n * '<S21>'  : 'omni_attitude_controller/Quaternions to  Direction Cosine Matrix1/A21'\n * '<S22>'  : 'omni_attitude_controller/Quaternions to  Direction Cosine Matrix1/A22'\n * '<S23>'  : 'omni_attitude_controller/Quaternions to  Direction Cosine Matrix1/A23'\n * '<S24>'  : 'omni_attitude_controller/Quaternions to  Direction Cosine Matrix1/A31'\n * '<S25>'  : 'omni_attitude_controller/Quaternions to  Direction Cosine Matrix1/A32'\n * '<S26>'  : 'omni_attitude_controller/Quaternions to  Direction Cosine Matrix1/A33'\n * '<S27>'  : 'omni_attitude_controller/Quaternions to  Direction Cosine Matrix1/Create 3x3 Matrix'\n * '<S28>'  : 'omni_attitude_controller/Quaternions to  Direction Cosine Matrix1/Quaternion Normalize'\n * '<S29>'  : 'omni_attitude_controller/Quaternions to  Direction Cosine Matrix1/Quaternion Normalize/Quaternion Modulus'\n * '<S30>'  : 'omni_attitude_controller/Quaternions to  Direction Cosine Matrix1/Quaternion Normalize/Quaternion Modulus/Quaternion Norm'\n */\n#endif                              /* RTW_HEADER_omni_attitude_controller_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"omni_attitude_controller_private.h","type":"header","group":"model","path":"/Users/wenshengfan/Documents/MATLAB/OAUAVSimluator/omni_attitude_controller_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: omni_attitude_controller_private.h\n *\n * Code generated for Simulink model 'omni_attitude_controller'.\n *\n * Model version                  : 8.7\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\n * C/C++ source code generated on : Thu Dec 14 15:57:15 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_omni_attitude_controller_private_h_\n#define RTW_HEADER_omni_attitude_controller_private_h_\n#include \"rtwtypes.h\"\n#include \"omni_attitude_controller_types.h\"\n#endif                      /* RTW_HEADER_omni_attitude_controller_private_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"omni_attitude_controller_types.h","type":"header","group":"model","path":"/Users/wenshengfan/Documents/MATLAB/OAUAVSimluator/omni_attitude_controller_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: omni_attitude_controller_types.h\n *\n * Code generated for Simulink model 'omni_attitude_controller'.\n *\n * Model version                  : 8.7\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\n * C/C++ source code generated on : Thu Dec 14 15:57:15 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_omni_attitude_controller_types_h_\n#define RTW_HEADER_omni_attitude_controller_types_h_\n\n/* Parameters (default storage) */\ntypedef struct P_omni_attitude_controller_T_ P_omni_attitude_controller_T;\n\n#endif                        /* RTW_HEADER_omni_attitude_controller_types_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"omni_attitude_controller_data.c","type":"source","group":"data","path":"/Users/wenshengfan/Documents/MATLAB/OAUAVSimluator/omni_attitude_controller_ert_rtw","tag":"","groupDisplay":"Data files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: omni_attitude_controller_data.c\n *\n * Code generated for Simulink model 'omni_attitude_controller'.\n *\n * Model version                  : 8.7\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\n * C/C++ source code generated on : Thu Dec 14 15:57:15 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#include \"omni_attitude_controller.h\"\n\n/* Block parameters (default storage) */\nP_omni_attitude_controller_T omni_attitude_controller_P = {\n  /* Variable: Ji\n   * Referenced by: '<Root>/LLATC'\n   */\n  { 1.2E-5, 0.0, 0.0, 0.0, 1.2E-5, 0.0, 0.0, 0.0, 2.2E-5 },\n\n  /* Variable: KR\n   * Referenced by: '<Root>/LLATC'\n   */\n  { 333.0, 0.0, 0.0, 0.0, 333.0, 0.0, 0.0, 0.0, 272.0 },\n\n  /* Variable: Ki\n   * Referenced by: '<Root>/LLATC'\n   */\n  { 1.67, 0.0, 0.0, 0.0, 1.67, 0.0, 0.0, 0.0, 1.82 },\n\n  /* Variable: Kw\n   * Referenced by: '<Root>/LLATC'\n   */\n  { 62.5, 0.0, 0.0, 0.0, 62.5, 0.0, 0.0, 0.0, 45.0 },\n\n  /* Expression: (31.65e-3)/(5.964552e-3)\n   * Referenced by: '<Root>/Constant'\n   */\n  5.30634991529959,\n\n  /* Computed Parameter: Saturation_UpperSat\n   * Referenced by: '<Root>/Saturation'\n   */\n  0.7F,\n\n  /* Computed Parameter: Saturation_LowerSat\n   * Referenced by: '<Root>/Saturation'\n   */\n  0.0F,\n\n  /* Computed Parameter: Gain_Gain\n   * Referenced by: '<S8>/Gain'\n   */\n  2.0F,\n\n  /* Computed Parameter: Gain_Gain_l\n   * Referenced by: '<S11>/Gain'\n   */\n  2.0F,\n\n  /* Computed Parameter: Gain_Gain_f\n   * Referenced by: '<S6>/Gain'\n   */\n  2.0F,\n\n  /* Computed Parameter: Gain_Gain_d\n   * Referenced by: '<S12>/Gain'\n   */\n  2.0F,\n\n  /* Computed Parameter: Gain_Gain_b\n   * Referenced by: '<S7>/Gain'\n   */\n  2.0F,\n\n  /* Computed Parameter: Gain_Gain_c\n   * Referenced by: '<S10>/Gain'\n   */\n  2.0F,\n\n  /* Computed Parameter: Gain_Gain_p\n   * Referenced by: '<S21>/Gain'\n   */\n  2.0F,\n\n  /* Computed Parameter: Gain_Gain_i\n   * Referenced by: '<S24>/Gain'\n   */\n  2.0F,\n\n  /* Computed Parameter: Gain_Gain_fl\n   * Referenced by: '<S19>/Gain'\n   */\n  2.0F,\n\n  /* Computed Parameter: Gain_Gain_a\n   * Referenced by: '<S25>/Gain'\n   */\n  2.0F,\n\n  /* Computed Parameter: Gain_Gain_h\n   * Referenced by: '<S20>/Gain'\n   */\n  2.0F,\n\n  /* Computed Parameter: Gain_Gain_ao\n   * Referenced by: '<S23>/Gain'\n   */\n  2.0F,\n\n  /* Computed Parameter: Memory5_InitialCondition\n   * Referenced by: '<Root>/Memory5'\n   */\n  { 0.0F, 0.0F, 0.0F },\n\n  /* Computed Parameter: Saturation1_UpperSat\n   * Referenced by: '<Root>/Saturation1'\n   */\n  65535.0F,\n\n  /* Computed Parameter: Saturation1_LowerSat\n   * Referenced by: '<Root>/Saturation1'\n   */\n  0.0F\n};\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rtGetInf.c","type":"source","group":"utility","path":"/Users/wenshengfan/Documents/MATLAB/OAUAVSimluator/omni_attitude_controller_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rtGetInf.c\n *\n * Code generated for Simulink model 'omni_attitude_controller'.\n *\n * Model version                  : 8.7\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\n * C/C++ source code generated on : Thu Dec 14 15:57:15 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n#include \"rtGetInf.h\"\n#include <stddef.h>\n#include \"rt_nonfinite.h\"\n#define NumBitsPerChar                 8U\n\n/*\n * Initialize rtInf needed by the generated code.\n * Inf is initialized as non-signaling. Assumes IEEE.\n */\nreal_T rtGetInf(void)\n{\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n  real_T inf = 0.0;\n  if (bitsPerReal == 32U) {\n    inf = rtGetInfF();\n  } else {\n    union {\n      LittleEndianIEEEDouble bitVal;\n      real_T fltVal;\n    } tmpVal;\n\n    tmpVal.bitVal.words.wordH = 0x7FF00000U;\n    tmpVal.bitVal.words.wordL = 0x00000000U;\n    inf = tmpVal.fltVal;\n  }\n\n  return inf;\n}\n\n/*\n * Initialize rtInfF needed by the generated code.\n * Inf is initialized as non-signaling. Assumes IEEE.\n */\nreal32_T rtGetInfF(void)\n{\n  IEEESingle infF;\n  infF.wordL.wordLuint = 0x7F800000U;\n  return infF.wordL.wordLreal;\n}\n\n/*\n * Initialize rtMinusInf needed by the generated code.\n * Inf is initialized as non-signaling. Assumes IEEE.\n */\nreal_T rtGetMinusInf(void)\n{\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n  real_T minf = 0.0;\n  if (bitsPerReal == 32U) {\n    minf = rtGetMinusInfF();\n  } else {\n    union {\n      LittleEndianIEEEDouble bitVal;\n      real_T fltVal;\n    } tmpVal;\n\n    tmpVal.bitVal.words.wordH = 0xFFF00000U;\n    tmpVal.bitVal.words.wordL = 0x00000000U;\n    minf = tmpVal.fltVal;\n  }\n\n  return minf;\n}\n\n/*\n * Initialize rtMinusInfF needed by the generated code.\n * Inf is initialized as non-signaling. Assumes IEEE.\n */\nreal32_T rtGetMinusInfF(void)\n{\n  IEEESingle minfF;\n  minfF.wordL.wordLuint = 0xFF800000U;\n  return minfF.wordL.wordLreal;\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"/Users/wenshengfan/Documents/MATLAB/OAUAVSimluator/omni_attitude_controller_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rtGetInf.h\n *\n * Code generated for Simulink model 'omni_attitude_controller'.\n *\n * Model version                  : 8.7\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\n * C/C++ source code generated on : Thu Dec 14 15:57:15 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtGetInf_h_\n#define RTW_HEADER_rtGetInf_h_\n#include \"rt_nonfinite.h\"\n#include \"rtwtypes.h\"\n\nextern real_T rtGetInf(void);\nextern real32_T rtGetInfF(void);\nextern real_T rtGetMinusInf(void);\nextern real32_T rtGetMinusInfF(void);\n\n#endif                                 /* RTW_HEADER_rtGetInf_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rtGetNaN.c","type":"source","group":"utility","path":"/Users/wenshengfan/Documents/MATLAB/OAUAVSimluator/omni_attitude_controller_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rtGetNaN.c\n *\n * Code generated for Simulink model 'omni_attitude_controller'.\n *\n * Model version                  : 8.7\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\n * C/C++ source code generated on : Thu Dec 14 15:57:15 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n#include \"rtGetNaN.h\"\n#include <stddef.h>\n#include \"rt_nonfinite.h\"\n#define NumBitsPerChar                 8U\n\n/*\n * Initialize rtNaN needed by the generated code.\n * NaN is initialized as non-signaling. Assumes IEEE.\n */\nreal_T rtGetNaN(void)\n{\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n  real_T nan = 0.0;\n  if (bitsPerReal == 32U) {\n    nan = rtGetNaNF();\n  } else {\n    union {\n      LittleEndianIEEEDouble bitVal;\n      real_T fltVal;\n    } tmpVal;\n\n    tmpVal.bitVal.words.wordH = 0xFFF80000U;\n    tmpVal.bitVal.words.wordL = 0x00000000U;\n    nan = tmpVal.fltVal;\n  }\n\n  return nan;\n}\n\n/*\n * Initialize rtNaNF needed by the generated code.\n * NaN is initialized as non-signaling. Assumes IEEE.\n */\nreal32_T rtGetNaNF(void)\n{\n  IEEESingle nanF = { { 0.0F } };\n\n  nanF.wordL.wordLuint = 0xFFC00000U;\n  return nanF.wordL.wordLreal;\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"/Users/wenshengfan/Documents/MATLAB/OAUAVSimluator/omni_attitude_controller_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rtGetNaN.h\n *\n * Code generated for Simulink model 'omni_attitude_controller'.\n *\n * Model version                  : 8.7\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\n * C/C++ source code generated on : Thu Dec 14 15:57:15 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtGetNaN_h_\n#define RTW_HEADER_rtGetNaN_h_\n#include \"rt_nonfinite.h\"\n#include \"rtwtypes.h\"\n\nextern real_T rtGetNaN(void);\nextern real32_T rtGetNaNF(void);\n\n#endif                                 /* RTW_HEADER_rtGetNaN_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rt_nonfinite.c","type":"source","group":"utility","path":"/Users/wenshengfan/Documents/MATLAB/OAUAVSimluator/omni_attitude_controller_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rt_nonfinite.c\n *\n * Code generated for Simulink model 'omni_attitude_controller'.\n *\n * Model version                  : 8.7\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\n * C/C++ source code generated on : Thu Dec 14 15:57:15 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#include \"rtGetNaN.h\"\n#include \"rtGetInf.h\"\n#include <stddef.h>\n#include \"rtwtypes.h\"\n#include \"rt_nonfinite.h\"\n#define NumBitsPerChar                 8U\n\nreal_T rtInf;\nreal_T rtMinusInf;\nreal_T rtNaN;\nreal32_T rtInfF;\nreal32_T rtMinusInfF;\nreal32_T rtNaNF;\n\n/*\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\n */\nvoid rt_InitInfAndNaN(size_t realSize)\n{\n  (void) (realSize);\n  rtNaN = rtGetNaN();\n  rtNaNF = rtGetNaNF();\n  rtInf = rtGetInf();\n  rtInfF = rtGetInfF();\n  rtMinusInf = rtGetMinusInf();\n  rtMinusInfF = rtGetMinusInfF();\n}\n\n/* Test if value is infinite */\nboolean_T rtIsInf(real_T value)\n{\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\n}\n\n/* Test if single-precision value is infinite */\nboolean_T rtIsInfF(real32_T value)\n{\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\n}\n\n/* Test if value is not a number */\nboolean_T rtIsNaN(real_T value)\n{\n  boolean_T result = (boolean_T) 0;\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n  if (bitsPerReal == 32U) {\n    result = rtIsNaNF((real32_T)value);\n  } else {\n    union {\n      LittleEndianIEEEDouble bitVal;\n      real_T fltVal;\n    } tmpVal;\n\n    tmpVal.fltVal = value;\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\n                          (tmpVal.bitVal.words.wordL != 0) ));\n  }\n\n  return result;\n}\n\n/* Test if single-precision value is not a number */\nboolean_T rtIsNaNF(real32_T value)\n{\n  IEEESingle tmp;\n  tmp.wordL.wordLreal = value;\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"/Users/wenshengfan/Documents/MATLAB/OAUAVSimluator/omni_attitude_controller_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rt_nonfinite.h\n *\n * Code generated for Simulink model 'omni_attitude_controller'.\n *\n * Model version                  : 8.7\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\n * C/C++ source code generated on : Thu Dec 14 15:57:15 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rt_nonfinite_h_\n#define RTW_HEADER_rt_nonfinite_h_\n#include <stddef.h>\n#include \"rtwtypes.h\"\n#define NOT_USING_NONFINITE_LITERALS   1\n\nextern real_T rtInf;\nextern real_T rtMinusInf;\nextern real_T rtNaN;\nextern real32_T rtInfF;\nextern real32_T rtMinusInfF;\nextern real32_T rtNaNF;\nextern void rt_InitInfAndNaN(size_t realSize);\nextern boolean_T rtIsInf(real_T value);\nextern boolean_T rtIsInfF(real32_T value);\nextern boolean_T rtIsNaN(real_T value);\nextern boolean_T rtIsNaNF(real32_T value);\ntypedef struct {\n  struct {\n    uint32_T wordH;\n    uint32_T wordL;\n  } words;\n} BigEndianIEEEDouble;\n\ntypedef struct {\n  struct {\n    uint32_T wordL;\n    uint32_T wordH;\n  } words;\n} LittleEndianIEEEDouble;\n\ntypedef struct {\n  union {\n    real32_T wordLreal;\n    uint32_T wordLuint;\n  } wordL;\n} IEEESingle;\n\n#endif                                 /* RTW_HEADER_rt_nonfinite_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"/Users/wenshengfan/Documents/MATLAB/OAUAVSimluator/omni_attitude_controller_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rtwtypes.h\n *\n * Code generated for Simulink model 'omni_attitude_controller'.\n *\n * Model version                  : 8.7\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\n * C/C++ source code generated on : Thu Dec 14 15:57:15 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objective: Execution efficiency\n * Validation result: Not run\n */\n\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n\n/* Logical type definitions */\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n\n/*=======================================================================*\n * Target hardware information\n *   Device type: Intel->x86-64 (Windows64)\n *   Number of bits:     char:   8    short:   16    int:  32\n *                       long:  32\n *                       native word size:  64\n *   Byte ordering: LittleEndian\n *   Signed integer division rounds to: Zero\n *   Shift right on a signed integer as arithmetic shift: on\n *=======================================================================*/\n\n/*=======================================================================*\n * Fixed width word size data types:                                     *\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\n *=======================================================================*/\ntypedef signed char int8_T;\ntypedef unsigned char uint8_T;\ntypedef short int16_T;\ntypedef unsigned short uint16_T;\ntypedef int int32_T;\ntypedef unsigned int uint32_T;\ntypedef float real32_T;\ntypedef double real64_T;\n\n/*===========================================================================*\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\n *                           real_T, time_T, ulong_T.                        *\n *===========================================================================*/\ntypedef double real_T;\ntypedef double time_T;\ntypedef unsigned char boolean_T;\ntypedef int int_T;\ntypedef unsigned int uint_T;\ntypedef unsigned long ulong_T;\ntypedef char char_T;\ntypedef unsigned char uchar_T;\ntypedef char_T byte_T;\n\n/*===========================================================================*\n * Complex number type definitions                                           *\n *===========================================================================*/\n#define CREAL_T\n\ntypedef struct {\n  real32_T re;\n  real32_T im;\n} creal32_T;\n\ntypedef struct {\n  real64_T re;\n  real64_T im;\n} creal64_T;\n\ntypedef struct {\n  real_T re;\n  real_T im;\n} creal_T;\n\n#define CINT8_T\n\ntypedef struct {\n  int8_T re;\n  int8_T im;\n} cint8_T;\n\n#define CUINT8_T\n\ntypedef struct {\n  uint8_T re;\n  uint8_T im;\n} cuint8_T;\n\n#define CINT16_T\n\ntypedef struct {\n  int16_T re;\n  int16_T im;\n} cint16_T;\n\n#define CUINT16_T\n\ntypedef struct {\n  uint16_T re;\n  uint16_T im;\n} cuint16_T;\n\n#define CINT32_T\n\ntypedef struct {\n  int32_T re;\n  int32_T im;\n} cint32_T;\n\n#define CUINT32_T\n\ntypedef struct {\n  uint32_T re;\n  uint32_T im;\n} cuint32_T;\n\n/*=======================================================================*\n * Min and Max:                                                          *\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n *=======================================================================*/\n#define MAX_int8_T                     ((int8_T)(127))\n#define MIN_int8_T                     ((int8_T)(-128))\n#define MAX_uint8_T                    ((uint8_T)(255U))\n#define MAX_int16_T                    ((int16_T)(32767))\n#define MIN_int16_T                    ((int16_T)(-32768))\n#define MAX_uint16_T                   ((uint16_T)(65535U))\n#define MAX_int32_T                    ((int32_T)(2147483647))\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\n\n/* Block D-Work pointer type */\ntypedef void * pointer_T;\n\n#endif                                 /* RTWTYPES_H */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true}};